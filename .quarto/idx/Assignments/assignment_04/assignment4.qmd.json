{"title":"Predictive Policing - Technical Implementation","markdown":{"yaml":{"title":"Predictive Policing - Technical Implementation","subtitle":"MUSA 5080 - Fall 2025","author":"Ryan Drake","date":"11/17/2025","format":{"html":{"code-fold":"show","code-tools":true,"toc":true,"toc-depth":3,"toc-location":"left","theme":"cosmo","embed-resources":true}},"editor":"visual","execute":{"warning":false,"message":false}},"headingText":"About This Assignment","containsRefs":false,"markdown":"\n\n\nThis assignment will build a spatial predictive model for Chicago tree debris 311 reports using count regression and spatial features:\n\n1.  Create a fishnet grid for aggregating point-level crime data\n2.  Calculate spatial features including k-nearest neighbors and distance measures\n3.  Diagnose spatial autocorrelation using Local Moran's I\n4.  Fit and interpret Poisson and Negative Binomial regression for count data\n5.  Implement spatial cross-validation (Leave-One-Group-Out)\n6.  Compare model predictions to a Kernel Density Estimation baseline\n7.  Evaluate model performance using appropriate metrics\n\n# Setup\n\n```{r setup}\n#| message: false\n#| warning: false\n\n# Load required packages\nlibrary(tidyverse)      # Data manipulation\nlibrary(sf)             # Spatial operations\nlibrary(here)           # Relative file paths\nlibrary(viridis)        # Color scales\nlibrary(terra)          # Raster operations (replaces 'raster')\nlibrary(spdep)          # Spatial dependence\nlibrary(FNN)            # Fast nearest neighbors\nlibrary(MASS)           # Negative binomial regression\nlibrary(patchwork)      # Plot composition (replaces grid/gridExtra)\nlibrary(knitr)          # Tables\nlibrary(kableExtra)     # Table formatting\nlibrary(classInt)       # Classification intervals\nlibrary(here)\n\n# Spatstat split into sub-packages\nlibrary(spatstat.geom)    # Spatial geometries\nlibrary(spatstat.explore) # Spatial exploration/KDE\n\n# Set options\noptions(scipen = 999)  # No scientific notation\nset.seed(5080)         # Reproducibility\n\n# Create consistent theme for visualizations\ntheme_crime <- function(base_size = 11) {\n  theme_minimal(base_size = base_size) +\n    theme(\n      plot.title = element_text(face = \"bold\", size = base_size + 1),\n      plot.subtitle = element_text(color = \"gray30\", size = base_size - 1),\n      legend.position = \"right\",\n      panel.grid.minor = element_blank(),\n      axis.text = element_blank(),\n      axis.title = element_blank()\n    )\n}\n\n# Set as default\ntheme_set(theme_crime())\n\ncat(\"✓ All packages loaded successfully!\\n\")\ncat(\"✓ Working directory:\", getwd(), \"\\n\")\n```\n\n# Part 1: Load and Explore Data\n\n## Exercise 1.1: Load Chicago Spatial Data\n\n```{r load-boundaries}\n#| message: false\n\n# Load police districts (used for spatial cross-validation)\npoliceDistricts <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/24zt-jpfn?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(District = dist_num)\n\n# Load police beats (smaller administrative units)\npoliceBeats <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/n9it-hstw?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(Beat = beat_num)\n\n# Load Chicago boundary\nchicagoBoundary <- \n  st_read(\"https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/Chapter5/chicagoBoundary.geojson\") %>%\n  st_transform('ESRI:102271')\n\ncat(\"✓ Loaded spatial boundaries\\n\")\ncat(\"  - Police districts:\", nrow(policeDistricts), \"\\n\")\ncat(\"  - Police beats:\", nrow(policeBeats), \"\\n\")\n```\n\n::: callout-note\n## Coordinate Reference System\n\nWe're using `ESRI:102271` (Illinois State Plane East, NAD83, US Feet). This is appropriate for Chicago because:\n\n-   It minimizes distortion in this region\n-   Uses feet (common in US planning)\n-   Allows accurate distance calculations\n:::\n\n## Exercise 1.2: Load Tree Debris Data\n\n```{r load-tree debris}\n#| message: false\n\n# Load from provided data file (downloaded from Chicago open data portal)\ntreedebris <- read_csv(here(\"Assignments/assignment_04/data\",\n                             \"311_Service_Requests_Tree_Debris.csv\"))\n\nnames(treedebris)\n\ntreedebris %>% \n  summarize(\n    n_rows = n(),\n    n_missing_lon = sum(is.na(Longitude)),\n    n_missing_lat = sum(is.na(Latitude))\n  )\n\ntreedebris_sf <- treedebris %>% \n  # keep only rows with both coords present\n  filter(!is.na(Longitude), !is.na(Latitude)) %>% \n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) %>% \n  st_transform(\"ESRI:102271\")\n\n\n# Check the data\ncat(\"\\n✓ Loaded treedebris data\\n\")\ncat(\"  - Number of treedebris:\", nrow(treedebris_sf), \"\\n\")\ncat(\"  - CRS:\", st_crs(treedebris_sf)$input, \"\\n\")\ncat(\"  - Date range:\", min(treedebris_sf$`Completion Date`, na.rm = TRUE), \"to\", \n    max(treedebris_sf$`Completion Date`, na.rm = TRUE), \"\\n\")\n```\n\n**Question 1.1:** How many tree debris reports are in the data set? What time period does this cover? Why does the coordinate reference system matter for our spatial analysis?\n\n*Your answer here:* There are 163,364 reports of completed tree debris reports within the data range of 01/02/2013 to 12/31/2015. Having this file in the Illinois State Plane East coordinate reference system (102271) will help to minimize distortion, it uses feet, and will make our distance calculations more accurate.\n\n## Exercise 1.3: Visualize Point Data\n\n```{r visualize-points}\n#| fig-width: 10\n#| fig-height: 5\n\n# Simple point map\np1 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_sf(data = treedebris_sf, color = \"#d62828\", size = 0.1, alpha = 0.4) +\n  labs(\n    title = \"Tree Debris Locations\",\n    subtitle = paste0(\"Chicago 2017, n = \", nrow(treedebris_sf))\n  )\n\n# Density surface using modern syntax\np2 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_density_2d_filled(\n    data = data.frame(st_coordinates(treedebris_sf)),\n    aes(X, Y),\n    alpha = 0.7,\n    bins = 8\n  ) +\n  scale_fill_viridis_d(\n    option = \"plasma\",\n    direction = -1,\n    guide = \"none\"  # Modern ggplot2 syntax (not guide = FALSE)\n  ) +\n  labs(\n    title = \"Density Surface\",\n    subtitle = \"Kernel density estimation\"\n  )\n\n# Combine plots using patchwork (modern approach)\np1 + p2 + \n  plot_annotation(\n    title = \"Spatial Distribution of Tree Debris in Chicago\",\n    tag_levels = 'A'\n  )\n```\n\n**Question 1.2:** What spatial patterns do you observe? Are tree debris evenly distributed across Chicago? Where are the highest concentrations? What might explain these patterns?\n\n*Your answer here:* Tree Debris reports seem to be evenly reported across Chicago. South Chicago sees less reports of tree debris and the density map shows this. Based on my own knowledge of the tree canopy of Chicago, South Chicago and the middle areas are less dense in canopy cover so there are less trees that would have tree debris. Even split would be expected nonetheless since tree debris would be evenly distributed based on weather and other outside factors.\n\n# Part 2: Create Fishnet Grid\n\n## Exercise 2.1: Understanding the Fishnet\n\n```{r create-fishnet}\n# Create 500m x 500m grid\nfishnet <- st_make_grid(\n  chicagoBoundary,\n  cellsize = 500,  # 500 meters per cell\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(uniqueID = row_number())\n\n# Keep only cells that intersect Chicago\nfishnet <- fishnet[chicagoBoundary, ]\n\n# View basic info\ncat(\"✓ Created fishnet grid\\n\")\ncat(\"  - Number of cells:\", nrow(fishnet), \"\\n\")\ncat(\"  - Cell size:\", 500, \"x\", 500, \"meters\\n\")\ncat(\"  - Cell area:\", round(st_area(fishnet[1,])), \"square meters\\n\")\n```\n\n**Question 2.1:** Why do we use a regular grid instead of existing boundaries like neighborhoods or census tracts? What are the advantages and disadvantages of this approach?\n\n*Your answer here:* The fishnet grid approach is a neutral way of forming a grid for spatial analysis. The equal sized cells make comparative analysis more consistent and can let you see fine detail of hot spots and other spatial analysis. However, since neighborhoods or census tracts are tied to administrative units, and they are thus tied to budgets, policies, etc., a regular grid is more difficult to apply to policy. There is also scale sensitivity of having too small or too large a grid which can impact interpretation.\n\n## Exercise 2.2: Aggregate Tree Debirs to Grid\n\n```{r treedebris-distribution}\ncat(\"\\nTree Debris count distribution:\\n\")\n\nsummary(fishnet$counttreedebris_sf)\n\ncat(\n  \"\\nCells with zero tree debris:\",\n  sum(fishnet$counttreedebris_sf == 0), \"/\", nrow(fishnet),\n  \"(\", round(100 * sum(fishnet$counttreedebris_sf == 0) / nrow(fishnet), 1), \"%)\\n\"\n)\n```\n\n```{r aggregate-tree debris}\n# Spatial join: which cell contains each tree debris?\ntreedebris_fishnet <- st_join(treedebris_sf, fishnet, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(counttreedebris_sf = n())\n\n# Join back to fishnet (cells with 0 burglaries will be NA)\nfishnet <- fishnet %>%\n  left_join(treedebris_fishnet, by = \"uniqueID\") %>%\n  mutate(counttreedebris_sf = replace_na(counttreedebris_sf, 0))\n\n# Summary statistics\ncat(\"\\nTree Debris count distribution:\\n\")\nsummary(fishnet$counttreedebris_sf)\ncat(\"\\nCells with zero tree debris:\", \n    sum(fishnet$counttreedebris_sf == 0), \n    \"/\", nrow(fishnet),\n    \"(\", round(100 * sum(fishnet$counttreedebris_sf == 0) / nrow(fishnet), 1), \"%)\\n\")\n```\n\n```{r visualize-fishnet}\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize aggregated counts\nggplot() +\n  geom_sf(data = fishnet, aes(fill = counttreedebris_sf), color = NA) +\n  geom_sf(data = chicagoBoundary, fill = NA, color = \"white\", linewidth = 1) +\n  scale_fill_viridis_c(\n    name = \"Tree Debris\",\n    option = \"plasma\",\n    trans = \"sqrt\",  # Square root for better visualization of skewed data\n    breaks = c(0, 1, 5, 10, 20, 40)\n  ) +\n  labs(\n    title = \"Tree Debris Counts by Grid Cell\",\n    subtitle = \"500m x 500m cells, Chicago 2013-2015\"\n  ) +\n  theme_crime()\n```\n\n**Question 2.2:** What is the distribution of tree debris counts across cells? Why do so many cells have zero tree debris? Is this distribution suitable for count regression? (Hint: look up overdispersion)\n\n*Your answer here:* The map shows largely blue pattern meaning most cells follow a zero distribution. The 311 reports are dependent on areas with trees, people reporting these activities, influenced by weather patterns, and can be in places there aren't as many trees like parking lots, industrial areas, or commercial areas. There is 12.9% that have zero tree debris count. This all makes the pattern strongly over dispersed. Thus this isn't suitable for count regression because there can't be negative counts.\n\n# Part 3: Create a Kernel Density Baseline\n\n```{r kde-baseline}\n#| message: false\n\n# Convert tree debris to ppp (point pattern) format for spatstat\ntreedebris_ppp <- as.ppp(\n  st_coordinates(treedebris_sf),\n  W = as.owin(st_bbox(chicagoBoundary))\n)\n\n# Calculate KDE with 1km bandwidth\nkde_treedebris <- density.ppp(\n  treedebris_ppp,\n  sigma = 1000,  # 1km bandwidth\n  edge = TRUE    # Edge correction\n)\n\n# Convert to terra raster (modern approach, not raster::raster)\nkde_raster <- rast(kde_treedebris)\n\n# Extract KDE values to fishnet cells\nfishnet <- fishnet %>%\n  mutate(\n    kde_value = terra::extract(\n      kde_raster,\n      vect(fishnet),\n      fun = mean,\n      na.rm = TRUE\n    )[, 2]  # Extract just the values column\n  )\n\ncat(\"✓ Calculated KDE baseline\\n\")\n```\n\n```{r visualize-kde}\n#| fig-width: 8\n#| fig-height: 6\n\nggplot() +\n  geom_sf(data = fishnet, aes(fill = kde_value), color = NA) +\n  geom_sf(data = chicagoBoundary, fill = NA, color = \"white\", linewidth = 1) +\n  scale_fill_viridis_c(\n    name = \"KDE Value\",\n    option = \"plasma\"\n  ) +\n  labs(\n    title = \"Kernel Density Estimation Baseline\",\n    subtitle = \"Simple spatial smoothing of tree debris locations\"\n  ) +\n  theme_crime()\n```\n\n**Question 3.1:** How does the KDE map compare to the count map? What does KDE capture well? What does it miss?\n\n*Your answer here:* The KDE captures a much smoother version of tree debris activity and its clusters. This gradient and neighborhood scale visualization better connects to the tree canopy cover and residential and storm response patterns. This is also helpful as isn't tied to the grid so it can be more interpret-able. The KDE is still not counts though, just intensity map. So it doesn't show actual numbers of tree debris requests or even which cells actually contain the requests. It also depends on size and location such as similar count cells make look similar after this kind of smoothing or spreading influence to areas of industrial or commercial which have a lower tree canopy but smoothing spreads into these areas. KDE is simply just an overall pattern.\n\n# Part 4: Create Spatial Predictor Variables\n\n## Exercise 4.1: Load 311 Pothole Calls\n\n```{r load-potholes}\n#| message: false\n# Load from provided data file (downloaded from Chicago open data portal)\npotholes <- read_csv(here(\"Assignments/assignment_04/data\",\n                             \"311_Service_Requests_Pot_Holes.csv\"))\n\nnames(potholes)\n\npotholes %>% \n  summarize(\n    n_rows = n(),\n    n_missing_lon = sum(is.na(LONGITUDE)),\n    n_missing_lat = sum(is.na(LATITUDE))\n  )\n\npotholes_sf <- potholes %>% \n  # keep only rows with both coords present\n  filter(!is.na(LONGITUDE), !is.na(LATITUDE)) %>% \n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs = 4326) %>% \n  st_transform(\"ESRI:102271\")\n\n\n# Check the data\ncat(\"\\n✓ Loaded potholes data\\n\")\ncat(\"  - Number of potholes:\", nrow(potholes_sf), \"\\n\")\ncat(\"  - CRS:\", st_crs(potholes_sf)$input, \"\\n\")\ncat(\"  - Date range:\", min(potholes_sf$`CREATION DATE`, na.rm = TRUE), \"to\", \n    max(potholes_sf$`CREATION DATE`, na.rm = TRUE), \"\\n\")\n```\n\n## Exercise 4.2: Count of Pot Holes per Cell\n\n```{r count-pot holes}\n# Aggregate pothole calls to fishnet\npotholes_fishnet <- st_join(potholes_sf, fishnet, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(potholes_sf = n())\n\n# Join to fishnet\nfishnet <- fishnet %>%\n  left_join(potholes_fishnet, by = \"uniqueID\") %>%\n  mutate(potholes_sf = replace_na(potholes_sf, 0))\n\ncat(\"Potholes distribution:\\n\")\nsummary(fishnet$potholes_sf)\n```\n\n```{r visualize-potholes}\n#| fig-width: 10\n#| fig-height: 4\n\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = counttreedebris_sf), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"magma\") +\n  labs(title = \"Tree Debris 311 Calls\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = potholes_sf), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\") +\n  labs(title = \"Potholes\") +\n  theme_crime()\n\np1 + p2 +\n  plot_annotation(title = \"Are tree debris and potholes correlated?\")\n```\n\n**Question 4.1:** Do you see a visual relationship between tree debris and potholes? What does this suggest?\n\n*Your answer here:* Firstly, potholes occur much more frequently so the map for that is more intense. There is some strong spatial overlap in South and Southwest Chicago and moderate overlap in Northern Chicago. It doesn't seem like a strong relationship but this may show areas of aging residential streets or aging areas where things are reported. There is also the case of weathering of streets. Chicago is known as the \"windy city\" and weather can help create storm damage or freeze/thaw for potholes so these areas of Chicago may see similar patterns. This all suggests using potholes as a predictive variable.\n\n## Exercise 4.3: Nearest Neighbor Features\n\n```{r nn-feature}\n#| message: false\n\n# Calculate mean distance to 3 nearest potholes\n# (Do this OUTSIDE of mutate to avoid sf conflicts)\n\n# Get coordinates\nfishnet_coords <- st_coordinates(st_centroid(fishnet))\npotholes_coords <- st_coordinates(potholes_sf)\n\n# Check error for k nearest neighbor because coords have NA\ncolSums(is.na(potholes_coords))\ncolSums(is.na(fishnet_coords))\n\n#fix invalid rows for Potholes\nvalid_rows <- complete.cases(potholes_coords)\npotholes_coords <- potholes_coords[valid_rows, , drop = FALSE]\n\n# Calculate k nearest neighbors and distances\nnn_result <- get.knnx(potholes_coords, fishnet_coords, k = 3)\n\n# Add to fishnet\nfishnet <- fishnet %>%\n  mutate(\n    potholes_sf.nn = rowMeans(nn_result$nn.dist)\n  )\n\ncat(\"✓ Calculated nearest neighbor distances\\n\")\nsummary(fishnet$potholes_sf.nn)\n```\n\n**Question 4.2:** What does a low value of `potholes_sf.nn` mean? A high value? Why might this be informative?\n\n*Your answer here:* A low pothole.nn means that there is a lot of activity of reports so may be an area with more potholes or more disorder. Potholes would cluster with a low value. The high value would be the opposite where there are limited potholes or lower disorder. This would help see pothole activity at the neighborhood level.\n\n## Exercise 4.4: Distance to Hot Spots using Local Moran's I\n\n```{r local-morans-potholes}\n# Function to calculate Local Moran's I\ncalculate_local_morans <- function(data, variable, k = 5) {\n  \n  # Create spatial weights\n  coords <- st_coordinates(st_centroid(data))\n  neighbors <- knn2nb(knearneigh(coords, k = k))\n  weights <- nb2listw(neighbors, style = \"W\", zero.policy = TRUE)\n  \n  # Calculate Local Moran's I\n  local_moran <- localmoran(data[[variable]], weights)\n  \n  # Classify clusters\n  mean_val <- mean(data[[variable]], na.rm = TRUE)\n  \n  data %>%\n    mutate(\n      local_i = local_moran[, 1],\n      p_value = local_moran[, 5],\n      is_significant = p_value < 0.05,\n      \n      moran_class = case_when(\n        !is_significant ~ \"Not Significant\",\n        local_i > 0 & .data[[variable]] > mean_val ~ \"High-High\",\n        local_i > 0 & .data[[variable]] <= mean_val ~ \"Low-Low\",\n        local_i < 0 & .data[[variable]] > mean_val ~ \"High-Low\",\n        local_i < 0 & .data[[variable]] <= mean_val ~ \"Low-High\",\n        TRUE ~ \"Not Significant\"\n      )\n    )\n}\n\n# Apply to Potholes\nfishnet <- calculate_local_morans(fishnet, \"potholes_sf\", k = 5)\n```\n\n```{r visualize-morans}\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize hot spots\nggplot() +\n  geom_sf(\n    data = fishnet, \n    aes(fill = moran_class), \n    color = NA\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"High-High\" = \"#d7191c\",\n      \"High-Low\" = \"#fdae61\",\n      \"Low-High\" = \"#abd9e9\",\n      \"Low-Low\" = \"#2c7bb6\",\n      \"Not Significant\" = \"gray90\"\n    ),\n    name = \"Cluster Type\"\n  ) +\n  labs(\n    title = \"Local Moran's I: Potholes Clusters\",\n    subtitle = \"High-High = Hot spots of disorder\"\n  ) +\n  theme_crime()\n```\n\n```{r distance-to-hotspots}\n# Get centroids of \"High-High\" cells (hot spots)\nhotspots <- fishnet %>%\n  filter(moran_class == \"High-High\") %>%\n  st_centroid()\n\n# Calculate distance from each cell to nearest hot spot\nif (nrow(hotspots) > 0) {\n  fishnet <- fishnet %>%\n    mutate(\n      dist_to_hotspot = as.numeric(\n        st_distance(st_centroid(fishnet), hotspots %>% st_union())\n      )\n    )\n  \n  cat(\"✓ Calculated distance to pothole hot spots\\n\")\n  cat(\"  - Number of hot spot cells:\", nrow(hotspots), \"\\n\")\n} else {\n  fishnet <- fishnet %>%\n    mutate(dist_to_hotspot = 0)\n  cat(\"⚠ No significant hot spots found\\n\")\n}\n```\n\n**Question 4.3:** Why might distance to a cluster of potholes be more informative than distance to a single pothole? What does Local Moran's I tell us?\n\n*Your answer here:* Distance to a cluster of potholes gives us broader patterns of disorderly infrastructure rather than misleading us to isolated events or since one event doesn't reflect neighborhood conditions. Clusters are real spatial patterns. The local moran's I tells us the spatial autocorrelation at the local level. Meaning it tells us statistically signification areas where potholes concentrate and tells us when the disorder is clustered, dispersed, or random. It gives us better chronic disorder understanding at the neighborhood level.\n\n::: callout-note\n**Local Moran's I** identifies:\n\n-   **High-High**: Hot spots (high values surrounded by high values)\n-   **Low-Low**: Cold spots (low values surrounded by low values)\n-   **High-Low / Low-High**: Spatial outliers\n\nThis helps us understand spatial clustering patterns.\n:::\n\n------------------------------------------------------------------------\n\n# Part 5: Join Police Districts for Cross-Validation\n\n```{r join-districts}\n# Join district information to fishnet\nfishnet <- st_join(\n  fishnet,\n  policeDistricts,\n  join = st_within,\n  left = TRUE\n) %>%\n  filter(!is.na(District))  # Remove cells outside districts\n\ncat(\"✓ Joined police districts\\n\")\ncat(\"  - Districts:\", length(unique(fishnet$District)), \"\\n\")\ncat(\"  - Cells:\", nrow(fishnet), \"\\n\")\n```\n\n# Part 6: Model Fitting\n\n## Exercise 6.1: Poisson Regression\n\n```{r prepare-data}\n# Create clean modeling dataset\nfishnet_model <- fishnet %>%\n  st_drop_geometry() %>%\n  dplyr::select(\n    uniqueID,\n    District,\n    counttreedebris_sf,\n    potholes_sf,\n    potholes_sf.nn,\n    dist_to_hotspot\n  ) %>%\n  na.omit()  # Remove any remaining NAs\n\ncat(\"✓ Prepared modeling data\\n\")\ncat(\"  - Observations:\", nrow(fishnet_model), \"\\n\")\ncat(\"  - Variables:\", ncol(fishnet_model), \"\\n\")\n```\n\n```{r fit-poisson}\n# Fit Poisson regression\nmodel_poisson <- glm(\n  counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n    dist_to_hotspot,\n  data = fishnet_model,\n  family = \"poisson\"\n)\n\n# Summary\nsummary(model_poisson)\n```\n\n**Question 6.1:** Interpret the coefficients. Which variables are significant? What do the signs (positive/negative) tell you?\n\n*Your answer here:* All of the coefficients are highly significant. potholes_sf is showing that, because potholes counts are so large, that the broken windows theory we used is working that more potholes means more tree debris. The potholes_sf.nn is the strongest coefficient and is negative in contrast because it measures distance to a nearby pothole - as distance to be near a pothole increases the tree debris counts decrease thus the slope is negative. On the other hand, dist_to_hotspot is positive. Which is strange but it is because there are two distance measures that are related - potholes_sf.nn and dist_to_hotspot are collinear and thus dist_to_hotspot doesn't mean much here.\n\n## Exercise 6.2: Check for Overdispersion\n\n```{r check-overdispersion}\n# Calculate dispersion parameter\ndispersion <- sum(residuals(model_poisson, type = \"pearson\")^2) / \n              model_poisson$df.residual\n\ncat(\"Dispersion parameter:\", round(dispersion, 2), \"\\n\")\ncat(\"Rule of thumb: >1.5 suggests overdispersion\\n\")\n\nif (dispersion > 1.5) {\n  cat(\"⚠ Overdispersion detected! Consider Negative Binomial model.\\n\")\n} else {\n  cat(\"✓ Dispersion looks okay for Poisson model.\\n\")\n}\n```\n\n## Exercise 6.3: Negative Binomial Regression\n\n```{r fit-negbin}\n# Fit Negative Binomial model\nmodel_nb <- glm.nb(\n  counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n    dist_to_hotspot,\n  data = fishnet_model\n)\n\n# Summary\nsummary(model_nb)\n\n# Compare AIC (lower is better)\ncat(\"\\nModel Comparison:\\n\")\ncat(\"Poisson AIC:\", round(AIC(model_poisson), 1), \"\\n\")\ncat(\"Negative Binomial AIC:\", round(AIC(model_nb), 1), \"\\n\")\n```\n\n**Question 6.2:** Which model fits better (lower AIC)? What does this tell you about the data?\n\n*Your answer here:* The NB model has a way better AIC of 17256.8 than the Poisson of 89582.9. This shows the NB model, which dropped the potholes_sf count as non significant and reduced severity of dist_to_hotspot, is a better fit. Counts aren't helpful once distance is put in. Hotspot distance is just redundant. The NB model is showing that the only important predictor is proximity to potholes - the potholes_sf.nn variable.\n\n# Part 7: Spatial Cross-Validation\n\n**Leave-One-Group-Out (LOGO) Cross-Validation**\n\n```{r spatial-cv}\n# Get unique districts\ndistricts <- unique(fishnet_model$District)\ncv_results <- tibble()\n\ncat(\"Running LOGO Cross-Validation...\\n\")\n\nfor (i in seq_along(districts)) {\n  \n  test_district <- districts[i]\n  \n  # Split data\n  train_data <- fishnet_model %>% filter(District != test_district)\n  test_data <- fishnet_model %>% filter(District == test_district)\n  \n  # Fit model on training data\n  model_cv <- glm.nb(\n    counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n      dist_to_hotspot,\n    data = train_data\n  )\n  \n  # Predict on test data\n  test_data <- test_data %>%\n    mutate(\n      prediction = predict(model_cv, test_data, type = \"response\")\n    )\n  \n  # Calculate metrics\n  mae <- mean(abs(test_data$counttreedebris_sf - test_data$prediction))\n  rmse <- sqrt(mean((test_data$counttreedebris_sf - test_data$prediction)^2))\n  \n  # Store results\n  cv_results <- bind_rows(\n    cv_results,\n    tibble(\n      fold = i,\n      test_district = test_district,\n      n_test = nrow(test_data),\n      mae = mae,\n      rmse = rmse\n    )\n  )\n  \n  cat(\"  Fold\", i, \"/\", length(districts), \"- District\", test_district, \n      \"- MAE:\", round(mae, 2), \"\\n\")\n}\n\n# Overall results\ncat(\"\\n✓ Cross-Validation Complete\\n\")\ncat(\"Mean MAE:\", round(mean(cv_results$mae), 2), \"\\n\")\ncat(\"Mean RMSE:\", round(mean(cv_results$rmse), 2), \"\\n\")\n```\n\n```{r cv-results-table}\n# Show results\ncv_results %>%\n  arrange(desc(mae)) %>%\n  kable(\n    digits = 2,\n    caption = \"LOGO CV Results by District\"\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n**Question 7.1:** Why is spatial CV more appropriate than random CV for this problem? Which districts were hardest to predict?\n\n*Your answer here:* The MAE values range from 102.85 to 29.31 and RSME values range from 136.53 to 34.82. These are large variations which is what spatial CV does better - it can show where the model generalizes well and where it doesn't. The models performance is a spatial problem by district - the relationship between tree debris and potholes isn't the same across the city. A random CV wouldn't capture this. Districts 22, 15, 1, 12 etc. were the hardest to predict.\n\n::: callout-note\n## Connection to Week 5\n\nRemember learning about train/test splits and cross-validation? This is a spatial version of that concept!\n\n**Why it matters:** If we can only predict well in areas we've already heavily policed, what does that tell us about the model's utility?\n:::\n\n# Part 8: Model Predictions and Comparison\n\n## Exercise 8.1: Generate Final Predictions\n\n```{r final-predictions}\n# Fit final model on all data\nfinal_model <- glm.nb(\n  counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n    dist_to_hotspot,\n  data = fishnet_model\n)\n\n# Add predictions back to fishnet\nfishnet <- fishnet %>%\n  mutate(\n    prediction_nb = predict(final_model, fishnet_model, type = \"response\")[match(uniqueID, fishnet_model$uniqueID)]\n  )\n\n# Also add KDE predictions (normalize to same scale as counts)\nkde_sum <- sum(fishnet$kde_value, na.rm = TRUE)\ncount_sum <- sum(fishnet$counttreedebris_sf, na.rm = TRUE)\nfishnet <- fishnet %>%\n  mutate(\n    prediction_kde = (kde_value / kde_sum) * count_sum\n  )\n```\n\n## Exercise 8.2: Compare Model vs. KDE Baseline\n\n```{r compare-models}\n#| fig-width: 12\n#| fig-height: 4\n\n# Create three maps\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = counttreedebris_sf), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Tree Debris\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Model Predictions (Neg. Binomial)\") +\n  theme_crime()\n\np3 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_kde), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"KDE Baseline Predictions\") +\n  theme_crime()\n\np1 + p2 + p3 +\n  plot_annotation(\n    title = \"Actual vs. Predicted Tree Debris\",\n    subtitle = \"Does our complex model outperform simple KDE?\"\n  )\n```\n\n```{r model-comparison-metrics}\n# Calculate performance metrics\ncomparison <- fishnet %>%\n  st_drop_geometry() %>%\n  filter(!is.na(prediction_nb), !is.na(prediction_kde)) %>%\n  summarize(\n    model_mae = mean(abs(counttreedebris_sf - prediction_nb)),\n    model_rmse = sqrt(mean((counttreedebris_sf - prediction_nb)^2)),\n    kde_mae = mean(abs(counttreedebris_sf - prediction_kde)),\n    kde_rmse = sqrt(mean((counttreedebris_sf - prediction_kde)^2))\n  )\n\ncomparison %>%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") %>%\n  separate(metric, into = c(\"approach\", \"metric\"), sep = \"_\") %>%\n  pivot_wider(names_from = metric, values_from = value) %>%\n  kable(\n    digits = 2,\n    caption = \"Model Performance Comparison\"\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n**Question 8.1:** Does the complex model outperform the simple KDE baseline? By how much? Is the added complexity worth it?\n\n*Your answer here:* The simple KDE outperformed the complex model by 15.86 MAE and 20.37 RMSE. The added complexity did not beat spatial smoothing - just added more explanatory variation. Tree debris is a spatial problem. The KDE baseline already captures the spatial pattern, spatial clustering, and neighborhood structure.\n\n## Exercise 9.3: Where Does the Model Work Well?\n\n```{r prediction-errors}\n#| fig-width: 10\n#| fig-height: 5\n\n# Calculate errors\nfishnet <- fishnet %>%\n  mutate(\n    error_nb = counttreedebris_sf - prediction_nb,\n    error_kde = counttreedebris_sf - prediction_kde,\n    abs_error_nb = abs(error_nb),\n    abs_error_kde = abs(error_kde)\n  )\n\n# Map errors\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = error_nb), color = NA) +\n  scale_fill_gradient2(\n    name = \"Error\",\n    low = \"#2166ac\", mid = \"white\", high = \"#b2182b\",\n    midpoint = 0,\n    limits = c(-10, 10)\n  ) +\n  labs(title = \"Model Errors (Actual - Predicted)\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = abs_error_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Abs. Error\", option = \"magma\") +\n  labs(title = \"Absolute Model Errors\") +\n  theme_crime()\n\np1 + p2\n```\n\n**Question 9.2:** Where does the model make the biggest errors? Are there spatial patterns in the errors? What might this reveal?\n\n*Your answer here:* Yes there are spatial patterns in the errors. The model makes the largest errors in the South and Southwest areas of Chicago. Also, a little bit in the Westside and Northside areas. The actual-predicted map shows underprediction in some of the districts and overprediciton in others, while the absolute error map shows neighborhoods where model performance is rather poor. There are other drivers that would happen with tree debris like I alluded to before such as tree canopy cover, land uses (industrial or commerical), storm intensity or exposure in certain areas over others, and just peoples reporting behaviors across neighborhoods that the model doesn't incorporate.\n\n# Part 10: Summary Statistics and Tables\n\n## Exercise 10.1: Model Summary Table\n\n```{r model-summary-table}\n# Create nice summary table\nmodel_summary <- broom::tidy(final_model, exponentiate = TRUE) %>%\n  mutate(\n    across(where(is.numeric), ~round(., 3))\n  )\n\nmodel_summary %>%\n  kable(\n    caption = \"Final Negative Binomial Model Coefficients (Exponentiated)\",\n    col.names = c(\"Variable\", \"Rate Ratio\", \"Std. Error\", \"Z\", \"P-Value\")\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  footnote(\n    general = \"Rate ratios > 1 indicate positive association with tree debris counts.\"\n  )\n```\n\n## Exercise 10.2: Key Findings Summary\n\n**Technical Performance:**\n\n-   Cross-validation MAE: 54.5\n-   Model vs. KDE: KDE\n-   Most predictive variable: potholes_sf.nn\n\n**Spatial Patterns:**\n\n-   Tree debris reports are clustered.\n-   Hot spots are located in South and Southwest neighborhoods and a little bit in the Westsides and Northsides of Chicago.\n-   Model errors show patterns of clustering of underprediciton and overprediction with district boundaries.\n\n**Model Limitations:**\n\n-   Overdispersion: Yes, by a lot. We had to use the NB model.\n-   Spatial autocorrelation in residuals: Yes, the error maps show clustered residuals.\n-   Cells with zero counts: 12.9%\n\n# Conclusion and Next Steps\n\nThis assignment has made a spatial prediction workflow for Chicago tree debris using 311 data and pothole as a predictor. While the Negative Binomial model identified strong relationships between disorder and tree debris, the spatial cross-validation and baseline comparison exercises demontrated that the KDE actually explains most of the variation anyway. Tree debris is strongly spatially autocorrelated, spatially clustered, and shaped by neighborhood(local)-level contextual factors that wern't in the model (like land use, storm exposure and intensities, and canopy cover). Future work should focus on incorporating tree canopy, storm data, other land use data.\n","srcMarkdownNoYaml":"\n\n## About This Assignment\n\nThis assignment will build a spatial predictive model for Chicago tree debris 311 reports using count regression and spatial features:\n\n1.  Create a fishnet grid for aggregating point-level crime data\n2.  Calculate spatial features including k-nearest neighbors and distance measures\n3.  Diagnose spatial autocorrelation using Local Moran's I\n4.  Fit and interpret Poisson and Negative Binomial regression for count data\n5.  Implement spatial cross-validation (Leave-One-Group-Out)\n6.  Compare model predictions to a Kernel Density Estimation baseline\n7.  Evaluate model performance using appropriate metrics\n\n# Setup\n\n```{r setup}\n#| message: false\n#| warning: false\n\n# Load required packages\nlibrary(tidyverse)      # Data manipulation\nlibrary(sf)             # Spatial operations\nlibrary(here)           # Relative file paths\nlibrary(viridis)        # Color scales\nlibrary(terra)          # Raster operations (replaces 'raster')\nlibrary(spdep)          # Spatial dependence\nlibrary(FNN)            # Fast nearest neighbors\nlibrary(MASS)           # Negative binomial regression\nlibrary(patchwork)      # Plot composition (replaces grid/gridExtra)\nlibrary(knitr)          # Tables\nlibrary(kableExtra)     # Table formatting\nlibrary(classInt)       # Classification intervals\nlibrary(here)\n\n# Spatstat split into sub-packages\nlibrary(spatstat.geom)    # Spatial geometries\nlibrary(spatstat.explore) # Spatial exploration/KDE\n\n# Set options\noptions(scipen = 999)  # No scientific notation\nset.seed(5080)         # Reproducibility\n\n# Create consistent theme for visualizations\ntheme_crime <- function(base_size = 11) {\n  theme_minimal(base_size = base_size) +\n    theme(\n      plot.title = element_text(face = \"bold\", size = base_size + 1),\n      plot.subtitle = element_text(color = \"gray30\", size = base_size - 1),\n      legend.position = \"right\",\n      panel.grid.minor = element_blank(),\n      axis.text = element_blank(),\n      axis.title = element_blank()\n    )\n}\n\n# Set as default\ntheme_set(theme_crime())\n\ncat(\"✓ All packages loaded successfully!\\n\")\ncat(\"✓ Working directory:\", getwd(), \"\\n\")\n```\n\n# Part 1: Load and Explore Data\n\n## Exercise 1.1: Load Chicago Spatial Data\n\n```{r load-boundaries}\n#| message: false\n\n# Load police districts (used for spatial cross-validation)\npoliceDistricts <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/24zt-jpfn?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(District = dist_num)\n\n# Load police beats (smaller administrative units)\npoliceBeats <- \n  st_read(\"https://data.cityofchicago.org/api/geospatial/n9it-hstw?method=export&format=GeoJSON\") %>%\n  st_transform('ESRI:102271') %>%\n  dplyr::select(Beat = beat_num)\n\n# Load Chicago boundary\nchicagoBoundary <- \n  st_read(\"https://raw.githubusercontent.com/urbanSpatial/Public-Policy-Analytics-Landing/master/DATA/Chapter5/chicagoBoundary.geojson\") %>%\n  st_transform('ESRI:102271')\n\ncat(\"✓ Loaded spatial boundaries\\n\")\ncat(\"  - Police districts:\", nrow(policeDistricts), \"\\n\")\ncat(\"  - Police beats:\", nrow(policeBeats), \"\\n\")\n```\n\n::: callout-note\n## Coordinate Reference System\n\nWe're using `ESRI:102271` (Illinois State Plane East, NAD83, US Feet). This is appropriate for Chicago because:\n\n-   It minimizes distortion in this region\n-   Uses feet (common in US planning)\n-   Allows accurate distance calculations\n:::\n\n## Exercise 1.2: Load Tree Debris Data\n\n```{r load-tree debris}\n#| message: false\n\n# Load from provided data file (downloaded from Chicago open data portal)\ntreedebris <- read_csv(here(\"Assignments/assignment_04/data\",\n                             \"311_Service_Requests_Tree_Debris.csv\"))\n\nnames(treedebris)\n\ntreedebris %>% \n  summarize(\n    n_rows = n(),\n    n_missing_lon = sum(is.na(Longitude)),\n    n_missing_lat = sum(is.na(Latitude))\n  )\n\ntreedebris_sf <- treedebris %>% \n  # keep only rows with both coords present\n  filter(!is.na(Longitude), !is.na(Latitude)) %>% \n  st_as_sf(coords = c(\"Longitude\", \"Latitude\"), crs = 4326) %>% \n  st_transform(\"ESRI:102271\")\n\n\n# Check the data\ncat(\"\\n✓ Loaded treedebris data\\n\")\ncat(\"  - Number of treedebris:\", nrow(treedebris_sf), \"\\n\")\ncat(\"  - CRS:\", st_crs(treedebris_sf)$input, \"\\n\")\ncat(\"  - Date range:\", min(treedebris_sf$`Completion Date`, na.rm = TRUE), \"to\", \n    max(treedebris_sf$`Completion Date`, na.rm = TRUE), \"\\n\")\n```\n\n**Question 1.1:** How many tree debris reports are in the data set? What time period does this cover? Why does the coordinate reference system matter for our spatial analysis?\n\n*Your answer here:* There are 163,364 reports of completed tree debris reports within the data range of 01/02/2013 to 12/31/2015. Having this file in the Illinois State Plane East coordinate reference system (102271) will help to minimize distortion, it uses feet, and will make our distance calculations more accurate.\n\n## Exercise 1.3: Visualize Point Data\n\n```{r visualize-points}\n#| fig-width: 10\n#| fig-height: 5\n\n# Simple point map\np1 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_sf(data = treedebris_sf, color = \"#d62828\", size = 0.1, alpha = 0.4) +\n  labs(\n    title = \"Tree Debris Locations\",\n    subtitle = paste0(\"Chicago 2017, n = \", nrow(treedebris_sf))\n  )\n\n# Density surface using modern syntax\np2 <- ggplot() + \n  geom_sf(data = chicagoBoundary, fill = \"gray95\", color = \"gray60\") +\n  geom_density_2d_filled(\n    data = data.frame(st_coordinates(treedebris_sf)),\n    aes(X, Y),\n    alpha = 0.7,\n    bins = 8\n  ) +\n  scale_fill_viridis_d(\n    option = \"plasma\",\n    direction = -1,\n    guide = \"none\"  # Modern ggplot2 syntax (not guide = FALSE)\n  ) +\n  labs(\n    title = \"Density Surface\",\n    subtitle = \"Kernel density estimation\"\n  )\n\n# Combine plots using patchwork (modern approach)\np1 + p2 + \n  plot_annotation(\n    title = \"Spatial Distribution of Tree Debris in Chicago\",\n    tag_levels = 'A'\n  )\n```\n\n**Question 1.2:** What spatial patterns do you observe? Are tree debris evenly distributed across Chicago? Where are the highest concentrations? What might explain these patterns?\n\n*Your answer here:* Tree Debris reports seem to be evenly reported across Chicago. South Chicago sees less reports of tree debris and the density map shows this. Based on my own knowledge of the tree canopy of Chicago, South Chicago and the middle areas are less dense in canopy cover so there are less trees that would have tree debris. Even split would be expected nonetheless since tree debris would be evenly distributed based on weather and other outside factors.\n\n# Part 2: Create Fishnet Grid\n\n## Exercise 2.1: Understanding the Fishnet\n\n```{r create-fishnet}\n# Create 500m x 500m grid\nfishnet <- st_make_grid(\n  chicagoBoundary,\n  cellsize = 500,  # 500 meters per cell\n  square = TRUE\n) %>%\n  st_sf() %>%\n  mutate(uniqueID = row_number())\n\n# Keep only cells that intersect Chicago\nfishnet <- fishnet[chicagoBoundary, ]\n\n# View basic info\ncat(\"✓ Created fishnet grid\\n\")\ncat(\"  - Number of cells:\", nrow(fishnet), \"\\n\")\ncat(\"  - Cell size:\", 500, \"x\", 500, \"meters\\n\")\ncat(\"  - Cell area:\", round(st_area(fishnet[1,])), \"square meters\\n\")\n```\n\n**Question 2.1:** Why do we use a regular grid instead of existing boundaries like neighborhoods or census tracts? What are the advantages and disadvantages of this approach?\n\n*Your answer here:* The fishnet grid approach is a neutral way of forming a grid for spatial analysis. The equal sized cells make comparative analysis more consistent and can let you see fine detail of hot spots and other spatial analysis. However, since neighborhoods or census tracts are tied to administrative units, and they are thus tied to budgets, policies, etc., a regular grid is more difficult to apply to policy. There is also scale sensitivity of having too small or too large a grid which can impact interpretation.\n\n## Exercise 2.2: Aggregate Tree Debirs to Grid\n\n```{r treedebris-distribution}\ncat(\"\\nTree Debris count distribution:\\n\")\n\nsummary(fishnet$counttreedebris_sf)\n\ncat(\n  \"\\nCells with zero tree debris:\",\n  sum(fishnet$counttreedebris_sf == 0), \"/\", nrow(fishnet),\n  \"(\", round(100 * sum(fishnet$counttreedebris_sf == 0) / nrow(fishnet), 1), \"%)\\n\"\n)\n```\n\n```{r aggregate-tree debris}\n# Spatial join: which cell contains each tree debris?\ntreedebris_fishnet <- st_join(treedebris_sf, fishnet, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(counttreedebris_sf = n())\n\n# Join back to fishnet (cells with 0 burglaries will be NA)\nfishnet <- fishnet %>%\n  left_join(treedebris_fishnet, by = \"uniqueID\") %>%\n  mutate(counttreedebris_sf = replace_na(counttreedebris_sf, 0))\n\n# Summary statistics\ncat(\"\\nTree Debris count distribution:\\n\")\nsummary(fishnet$counttreedebris_sf)\ncat(\"\\nCells with zero tree debris:\", \n    sum(fishnet$counttreedebris_sf == 0), \n    \"/\", nrow(fishnet),\n    \"(\", round(100 * sum(fishnet$counttreedebris_sf == 0) / nrow(fishnet), 1), \"%)\\n\")\n```\n\n```{r visualize-fishnet}\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize aggregated counts\nggplot() +\n  geom_sf(data = fishnet, aes(fill = counttreedebris_sf), color = NA) +\n  geom_sf(data = chicagoBoundary, fill = NA, color = \"white\", linewidth = 1) +\n  scale_fill_viridis_c(\n    name = \"Tree Debris\",\n    option = \"plasma\",\n    trans = \"sqrt\",  # Square root for better visualization of skewed data\n    breaks = c(0, 1, 5, 10, 20, 40)\n  ) +\n  labs(\n    title = \"Tree Debris Counts by Grid Cell\",\n    subtitle = \"500m x 500m cells, Chicago 2013-2015\"\n  ) +\n  theme_crime()\n```\n\n**Question 2.2:** What is the distribution of tree debris counts across cells? Why do so many cells have zero tree debris? Is this distribution suitable for count regression? (Hint: look up overdispersion)\n\n*Your answer here:* The map shows largely blue pattern meaning most cells follow a zero distribution. The 311 reports are dependent on areas with trees, people reporting these activities, influenced by weather patterns, and can be in places there aren't as many trees like parking lots, industrial areas, or commercial areas. There is 12.9% that have zero tree debris count. This all makes the pattern strongly over dispersed. Thus this isn't suitable for count regression because there can't be negative counts.\n\n# Part 3: Create a Kernel Density Baseline\n\n```{r kde-baseline}\n#| message: false\n\n# Convert tree debris to ppp (point pattern) format for spatstat\ntreedebris_ppp <- as.ppp(\n  st_coordinates(treedebris_sf),\n  W = as.owin(st_bbox(chicagoBoundary))\n)\n\n# Calculate KDE with 1km bandwidth\nkde_treedebris <- density.ppp(\n  treedebris_ppp,\n  sigma = 1000,  # 1km bandwidth\n  edge = TRUE    # Edge correction\n)\n\n# Convert to terra raster (modern approach, not raster::raster)\nkde_raster <- rast(kde_treedebris)\n\n# Extract KDE values to fishnet cells\nfishnet <- fishnet %>%\n  mutate(\n    kde_value = terra::extract(\n      kde_raster,\n      vect(fishnet),\n      fun = mean,\n      na.rm = TRUE\n    )[, 2]  # Extract just the values column\n  )\n\ncat(\"✓ Calculated KDE baseline\\n\")\n```\n\n```{r visualize-kde}\n#| fig-width: 8\n#| fig-height: 6\n\nggplot() +\n  geom_sf(data = fishnet, aes(fill = kde_value), color = NA) +\n  geom_sf(data = chicagoBoundary, fill = NA, color = \"white\", linewidth = 1) +\n  scale_fill_viridis_c(\n    name = \"KDE Value\",\n    option = \"plasma\"\n  ) +\n  labs(\n    title = \"Kernel Density Estimation Baseline\",\n    subtitle = \"Simple spatial smoothing of tree debris locations\"\n  ) +\n  theme_crime()\n```\n\n**Question 3.1:** How does the KDE map compare to the count map? What does KDE capture well? What does it miss?\n\n*Your answer here:* The KDE captures a much smoother version of tree debris activity and its clusters. This gradient and neighborhood scale visualization better connects to the tree canopy cover and residential and storm response patterns. This is also helpful as isn't tied to the grid so it can be more interpret-able. The KDE is still not counts though, just intensity map. So it doesn't show actual numbers of tree debris requests or even which cells actually contain the requests. It also depends on size and location such as similar count cells make look similar after this kind of smoothing or spreading influence to areas of industrial or commercial which have a lower tree canopy but smoothing spreads into these areas. KDE is simply just an overall pattern.\n\n# Part 4: Create Spatial Predictor Variables\n\n## Exercise 4.1: Load 311 Pothole Calls\n\n```{r load-potholes}\n#| message: false\n# Load from provided data file (downloaded from Chicago open data portal)\npotholes <- read_csv(here(\"Assignments/assignment_04/data\",\n                             \"311_Service_Requests_Pot_Holes.csv\"))\n\nnames(potholes)\n\npotholes %>% \n  summarize(\n    n_rows = n(),\n    n_missing_lon = sum(is.na(LONGITUDE)),\n    n_missing_lat = sum(is.na(LATITUDE))\n  )\n\npotholes_sf <- potholes %>% \n  # keep only rows with both coords present\n  filter(!is.na(LONGITUDE), !is.na(LATITUDE)) %>% \n  st_as_sf(coords = c(\"LONGITUDE\", \"LATITUDE\"), crs = 4326) %>% \n  st_transform(\"ESRI:102271\")\n\n\n# Check the data\ncat(\"\\n✓ Loaded potholes data\\n\")\ncat(\"  - Number of potholes:\", nrow(potholes_sf), \"\\n\")\ncat(\"  - CRS:\", st_crs(potholes_sf)$input, \"\\n\")\ncat(\"  - Date range:\", min(potholes_sf$`CREATION DATE`, na.rm = TRUE), \"to\", \n    max(potholes_sf$`CREATION DATE`, na.rm = TRUE), \"\\n\")\n```\n\n## Exercise 4.2: Count of Pot Holes per Cell\n\n```{r count-pot holes}\n# Aggregate pothole calls to fishnet\npotholes_fishnet <- st_join(potholes_sf, fishnet, join = st_within) %>%\n  st_drop_geometry() %>%\n  group_by(uniqueID) %>%\n  summarize(potholes_sf = n())\n\n# Join to fishnet\nfishnet <- fishnet %>%\n  left_join(potholes_fishnet, by = \"uniqueID\") %>%\n  mutate(potholes_sf = replace_na(potholes_sf, 0))\n\ncat(\"Potholes distribution:\\n\")\nsummary(fishnet$potholes_sf)\n```\n\n```{r visualize-potholes}\n#| fig-width: 10\n#| fig-height: 4\n\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = counttreedebris_sf), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"magma\") +\n  labs(title = \"Tree Debris 311 Calls\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = potholes_sf), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\") +\n  labs(title = \"Potholes\") +\n  theme_crime()\n\np1 + p2 +\n  plot_annotation(title = \"Are tree debris and potholes correlated?\")\n```\n\n**Question 4.1:** Do you see a visual relationship between tree debris and potholes? What does this suggest?\n\n*Your answer here:* Firstly, potholes occur much more frequently so the map for that is more intense. There is some strong spatial overlap in South and Southwest Chicago and moderate overlap in Northern Chicago. It doesn't seem like a strong relationship but this may show areas of aging residential streets or aging areas where things are reported. There is also the case of weathering of streets. Chicago is known as the \"windy city\" and weather can help create storm damage or freeze/thaw for potholes so these areas of Chicago may see similar patterns. This all suggests using potholes as a predictive variable.\n\n## Exercise 4.3: Nearest Neighbor Features\n\n```{r nn-feature}\n#| message: false\n\n# Calculate mean distance to 3 nearest potholes\n# (Do this OUTSIDE of mutate to avoid sf conflicts)\n\n# Get coordinates\nfishnet_coords <- st_coordinates(st_centroid(fishnet))\npotholes_coords <- st_coordinates(potholes_sf)\n\n# Check error for k nearest neighbor because coords have NA\ncolSums(is.na(potholes_coords))\ncolSums(is.na(fishnet_coords))\n\n#fix invalid rows for Potholes\nvalid_rows <- complete.cases(potholes_coords)\npotholes_coords <- potholes_coords[valid_rows, , drop = FALSE]\n\n# Calculate k nearest neighbors and distances\nnn_result <- get.knnx(potholes_coords, fishnet_coords, k = 3)\n\n# Add to fishnet\nfishnet <- fishnet %>%\n  mutate(\n    potholes_sf.nn = rowMeans(nn_result$nn.dist)\n  )\n\ncat(\"✓ Calculated nearest neighbor distances\\n\")\nsummary(fishnet$potholes_sf.nn)\n```\n\n**Question 4.2:** What does a low value of `potholes_sf.nn` mean? A high value? Why might this be informative?\n\n*Your answer here:* A low pothole.nn means that there is a lot of activity of reports so may be an area with more potholes or more disorder. Potholes would cluster with a low value. The high value would be the opposite where there are limited potholes or lower disorder. This would help see pothole activity at the neighborhood level.\n\n## Exercise 4.4: Distance to Hot Spots using Local Moran's I\n\n```{r local-morans-potholes}\n# Function to calculate Local Moran's I\ncalculate_local_morans <- function(data, variable, k = 5) {\n  \n  # Create spatial weights\n  coords <- st_coordinates(st_centroid(data))\n  neighbors <- knn2nb(knearneigh(coords, k = k))\n  weights <- nb2listw(neighbors, style = \"W\", zero.policy = TRUE)\n  \n  # Calculate Local Moran's I\n  local_moran <- localmoran(data[[variable]], weights)\n  \n  # Classify clusters\n  mean_val <- mean(data[[variable]], na.rm = TRUE)\n  \n  data %>%\n    mutate(\n      local_i = local_moran[, 1],\n      p_value = local_moran[, 5],\n      is_significant = p_value < 0.05,\n      \n      moran_class = case_when(\n        !is_significant ~ \"Not Significant\",\n        local_i > 0 & .data[[variable]] > mean_val ~ \"High-High\",\n        local_i > 0 & .data[[variable]] <= mean_val ~ \"Low-Low\",\n        local_i < 0 & .data[[variable]] > mean_val ~ \"High-Low\",\n        local_i < 0 & .data[[variable]] <= mean_val ~ \"Low-High\",\n        TRUE ~ \"Not Significant\"\n      )\n    )\n}\n\n# Apply to Potholes\nfishnet <- calculate_local_morans(fishnet, \"potholes_sf\", k = 5)\n```\n\n```{r visualize-morans}\n#| fig-width: 8\n#| fig-height: 6\n\n# Visualize hot spots\nggplot() +\n  geom_sf(\n    data = fishnet, \n    aes(fill = moran_class), \n    color = NA\n  ) +\n  scale_fill_manual(\n    values = c(\n      \"High-High\" = \"#d7191c\",\n      \"High-Low\" = \"#fdae61\",\n      \"Low-High\" = \"#abd9e9\",\n      \"Low-Low\" = \"#2c7bb6\",\n      \"Not Significant\" = \"gray90\"\n    ),\n    name = \"Cluster Type\"\n  ) +\n  labs(\n    title = \"Local Moran's I: Potholes Clusters\",\n    subtitle = \"High-High = Hot spots of disorder\"\n  ) +\n  theme_crime()\n```\n\n```{r distance-to-hotspots}\n# Get centroids of \"High-High\" cells (hot spots)\nhotspots <- fishnet %>%\n  filter(moran_class == \"High-High\") %>%\n  st_centroid()\n\n# Calculate distance from each cell to nearest hot spot\nif (nrow(hotspots) > 0) {\n  fishnet <- fishnet %>%\n    mutate(\n      dist_to_hotspot = as.numeric(\n        st_distance(st_centroid(fishnet), hotspots %>% st_union())\n      )\n    )\n  \n  cat(\"✓ Calculated distance to pothole hot spots\\n\")\n  cat(\"  - Number of hot spot cells:\", nrow(hotspots), \"\\n\")\n} else {\n  fishnet <- fishnet %>%\n    mutate(dist_to_hotspot = 0)\n  cat(\"⚠ No significant hot spots found\\n\")\n}\n```\n\n**Question 4.3:** Why might distance to a cluster of potholes be more informative than distance to a single pothole? What does Local Moran's I tell us?\n\n*Your answer here:* Distance to a cluster of potholes gives us broader patterns of disorderly infrastructure rather than misleading us to isolated events or since one event doesn't reflect neighborhood conditions. Clusters are real spatial patterns. The local moran's I tells us the spatial autocorrelation at the local level. Meaning it tells us statistically signification areas where potholes concentrate and tells us when the disorder is clustered, dispersed, or random. It gives us better chronic disorder understanding at the neighborhood level.\n\n::: callout-note\n**Local Moran's I** identifies:\n\n-   **High-High**: Hot spots (high values surrounded by high values)\n-   **Low-Low**: Cold spots (low values surrounded by low values)\n-   **High-Low / Low-High**: Spatial outliers\n\nThis helps us understand spatial clustering patterns.\n:::\n\n------------------------------------------------------------------------\n\n# Part 5: Join Police Districts for Cross-Validation\n\n```{r join-districts}\n# Join district information to fishnet\nfishnet <- st_join(\n  fishnet,\n  policeDistricts,\n  join = st_within,\n  left = TRUE\n) %>%\n  filter(!is.na(District))  # Remove cells outside districts\n\ncat(\"✓ Joined police districts\\n\")\ncat(\"  - Districts:\", length(unique(fishnet$District)), \"\\n\")\ncat(\"  - Cells:\", nrow(fishnet), \"\\n\")\n```\n\n# Part 6: Model Fitting\n\n## Exercise 6.1: Poisson Regression\n\n```{r prepare-data}\n# Create clean modeling dataset\nfishnet_model <- fishnet %>%\n  st_drop_geometry() %>%\n  dplyr::select(\n    uniqueID,\n    District,\n    counttreedebris_sf,\n    potholes_sf,\n    potholes_sf.nn,\n    dist_to_hotspot\n  ) %>%\n  na.omit()  # Remove any remaining NAs\n\ncat(\"✓ Prepared modeling data\\n\")\ncat(\"  - Observations:\", nrow(fishnet_model), \"\\n\")\ncat(\"  - Variables:\", ncol(fishnet_model), \"\\n\")\n```\n\n```{r fit-poisson}\n# Fit Poisson regression\nmodel_poisson <- glm(\n  counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n    dist_to_hotspot,\n  data = fishnet_model,\n  family = \"poisson\"\n)\n\n# Summary\nsummary(model_poisson)\n```\n\n**Question 6.1:** Interpret the coefficients. Which variables are significant? What do the signs (positive/negative) tell you?\n\n*Your answer here:* All of the coefficients are highly significant. potholes_sf is showing that, because potholes counts are so large, that the broken windows theory we used is working that more potholes means more tree debris. The potholes_sf.nn is the strongest coefficient and is negative in contrast because it measures distance to a nearby pothole - as distance to be near a pothole increases the tree debris counts decrease thus the slope is negative. On the other hand, dist_to_hotspot is positive. Which is strange but it is because there are two distance measures that are related - potholes_sf.nn and dist_to_hotspot are collinear and thus dist_to_hotspot doesn't mean much here.\n\n## Exercise 6.2: Check for Overdispersion\n\n```{r check-overdispersion}\n# Calculate dispersion parameter\ndispersion <- sum(residuals(model_poisson, type = \"pearson\")^2) / \n              model_poisson$df.residual\n\ncat(\"Dispersion parameter:\", round(dispersion, 2), \"\\n\")\ncat(\"Rule of thumb: >1.5 suggests overdispersion\\n\")\n\nif (dispersion > 1.5) {\n  cat(\"⚠ Overdispersion detected! Consider Negative Binomial model.\\n\")\n} else {\n  cat(\"✓ Dispersion looks okay for Poisson model.\\n\")\n}\n```\n\n## Exercise 6.3: Negative Binomial Regression\n\n```{r fit-negbin}\n# Fit Negative Binomial model\nmodel_nb <- glm.nb(\n  counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n    dist_to_hotspot,\n  data = fishnet_model\n)\n\n# Summary\nsummary(model_nb)\n\n# Compare AIC (lower is better)\ncat(\"\\nModel Comparison:\\n\")\ncat(\"Poisson AIC:\", round(AIC(model_poisson), 1), \"\\n\")\ncat(\"Negative Binomial AIC:\", round(AIC(model_nb), 1), \"\\n\")\n```\n\n**Question 6.2:** Which model fits better (lower AIC)? What does this tell you about the data?\n\n*Your answer here:* The NB model has a way better AIC of 17256.8 than the Poisson of 89582.9. This shows the NB model, which dropped the potholes_sf count as non significant and reduced severity of dist_to_hotspot, is a better fit. Counts aren't helpful once distance is put in. Hotspot distance is just redundant. The NB model is showing that the only important predictor is proximity to potholes - the potholes_sf.nn variable.\n\n# Part 7: Spatial Cross-Validation\n\n**Leave-One-Group-Out (LOGO) Cross-Validation**\n\n```{r spatial-cv}\n# Get unique districts\ndistricts <- unique(fishnet_model$District)\ncv_results <- tibble()\n\ncat(\"Running LOGO Cross-Validation...\\n\")\n\nfor (i in seq_along(districts)) {\n  \n  test_district <- districts[i]\n  \n  # Split data\n  train_data <- fishnet_model %>% filter(District != test_district)\n  test_data <- fishnet_model %>% filter(District == test_district)\n  \n  # Fit model on training data\n  model_cv <- glm.nb(\n    counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n      dist_to_hotspot,\n    data = train_data\n  )\n  \n  # Predict on test data\n  test_data <- test_data %>%\n    mutate(\n      prediction = predict(model_cv, test_data, type = \"response\")\n    )\n  \n  # Calculate metrics\n  mae <- mean(abs(test_data$counttreedebris_sf - test_data$prediction))\n  rmse <- sqrt(mean((test_data$counttreedebris_sf - test_data$prediction)^2))\n  \n  # Store results\n  cv_results <- bind_rows(\n    cv_results,\n    tibble(\n      fold = i,\n      test_district = test_district,\n      n_test = nrow(test_data),\n      mae = mae,\n      rmse = rmse\n    )\n  )\n  \n  cat(\"  Fold\", i, \"/\", length(districts), \"- District\", test_district, \n      \"- MAE:\", round(mae, 2), \"\\n\")\n}\n\n# Overall results\ncat(\"\\n✓ Cross-Validation Complete\\n\")\ncat(\"Mean MAE:\", round(mean(cv_results$mae), 2), \"\\n\")\ncat(\"Mean RMSE:\", round(mean(cv_results$rmse), 2), \"\\n\")\n```\n\n```{r cv-results-table}\n# Show results\ncv_results %>%\n  arrange(desc(mae)) %>%\n  kable(\n    digits = 2,\n    caption = \"LOGO CV Results by District\"\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n**Question 7.1:** Why is spatial CV more appropriate than random CV for this problem? Which districts were hardest to predict?\n\n*Your answer here:* The MAE values range from 102.85 to 29.31 and RSME values range from 136.53 to 34.82. These are large variations which is what spatial CV does better - it can show where the model generalizes well and where it doesn't. The models performance is a spatial problem by district - the relationship between tree debris and potholes isn't the same across the city. A random CV wouldn't capture this. Districts 22, 15, 1, 12 etc. were the hardest to predict.\n\n::: callout-note\n## Connection to Week 5\n\nRemember learning about train/test splits and cross-validation? This is a spatial version of that concept!\n\n**Why it matters:** If we can only predict well in areas we've already heavily policed, what does that tell us about the model's utility?\n:::\n\n# Part 8: Model Predictions and Comparison\n\n## Exercise 8.1: Generate Final Predictions\n\n```{r final-predictions}\n# Fit final model on all data\nfinal_model <- glm.nb(\n  counttreedebris_sf ~ potholes_sf + potholes_sf.nn + \n    dist_to_hotspot,\n  data = fishnet_model\n)\n\n# Add predictions back to fishnet\nfishnet <- fishnet %>%\n  mutate(\n    prediction_nb = predict(final_model, fishnet_model, type = \"response\")[match(uniqueID, fishnet_model$uniqueID)]\n  )\n\n# Also add KDE predictions (normalize to same scale as counts)\nkde_sum <- sum(fishnet$kde_value, na.rm = TRUE)\ncount_sum <- sum(fishnet$counttreedebris_sf, na.rm = TRUE)\nfishnet <- fishnet %>%\n  mutate(\n    prediction_kde = (kde_value / kde_sum) * count_sum\n  )\n```\n\n## Exercise 8.2: Compare Model vs. KDE Baseline\n\n```{r compare-models}\n#| fig-width: 12\n#| fig-height: 4\n\n# Create three maps\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = counttreedebris_sf), color = NA) +\n  scale_fill_viridis_c(name = \"Count\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Actual Tree Debris\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"Model Predictions (Neg. Binomial)\") +\n  theme_crime()\n\np3 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = prediction_kde), color = NA) +\n  scale_fill_viridis_c(name = \"Predicted\", option = \"plasma\", limits = c(0, 15)) +\n  labs(title = \"KDE Baseline Predictions\") +\n  theme_crime()\n\np1 + p2 + p3 +\n  plot_annotation(\n    title = \"Actual vs. Predicted Tree Debris\",\n    subtitle = \"Does our complex model outperform simple KDE?\"\n  )\n```\n\n```{r model-comparison-metrics}\n# Calculate performance metrics\ncomparison <- fishnet %>%\n  st_drop_geometry() %>%\n  filter(!is.na(prediction_nb), !is.na(prediction_kde)) %>%\n  summarize(\n    model_mae = mean(abs(counttreedebris_sf - prediction_nb)),\n    model_rmse = sqrt(mean((counttreedebris_sf - prediction_nb)^2)),\n    kde_mae = mean(abs(counttreedebris_sf - prediction_kde)),\n    kde_rmse = sqrt(mean((counttreedebris_sf - prediction_kde)^2))\n  )\n\ncomparison %>%\n  pivot_longer(everything(), names_to = \"metric\", values_to = \"value\") %>%\n  separate(metric, into = c(\"approach\", \"metric\"), sep = \"_\") %>%\n  pivot_wider(names_from = metric, values_from = value) %>%\n  kable(\n    digits = 2,\n    caption = \"Model Performance Comparison\"\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n**Question 8.1:** Does the complex model outperform the simple KDE baseline? By how much? Is the added complexity worth it?\n\n*Your answer here:* The simple KDE outperformed the complex model by 15.86 MAE and 20.37 RMSE. The added complexity did not beat spatial smoothing - just added more explanatory variation. Tree debris is a spatial problem. The KDE baseline already captures the spatial pattern, spatial clustering, and neighborhood structure.\n\n## Exercise 9.3: Where Does the Model Work Well?\n\n```{r prediction-errors}\n#| fig-width: 10\n#| fig-height: 5\n\n# Calculate errors\nfishnet <- fishnet %>%\n  mutate(\n    error_nb = counttreedebris_sf - prediction_nb,\n    error_kde = counttreedebris_sf - prediction_kde,\n    abs_error_nb = abs(error_nb),\n    abs_error_kde = abs(error_kde)\n  )\n\n# Map errors\np1 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = error_nb), color = NA) +\n  scale_fill_gradient2(\n    name = \"Error\",\n    low = \"#2166ac\", mid = \"white\", high = \"#b2182b\",\n    midpoint = 0,\n    limits = c(-10, 10)\n  ) +\n  labs(title = \"Model Errors (Actual - Predicted)\") +\n  theme_crime()\n\np2 <- ggplot() +\n  geom_sf(data = fishnet, aes(fill = abs_error_nb), color = NA) +\n  scale_fill_viridis_c(name = \"Abs. Error\", option = \"magma\") +\n  labs(title = \"Absolute Model Errors\") +\n  theme_crime()\n\np1 + p2\n```\n\n**Question 9.2:** Where does the model make the biggest errors? Are there spatial patterns in the errors? What might this reveal?\n\n*Your answer here:* Yes there are spatial patterns in the errors. The model makes the largest errors in the South and Southwest areas of Chicago. Also, a little bit in the Westside and Northside areas. The actual-predicted map shows underprediction in some of the districts and overprediciton in others, while the absolute error map shows neighborhoods where model performance is rather poor. There are other drivers that would happen with tree debris like I alluded to before such as tree canopy cover, land uses (industrial or commerical), storm intensity or exposure in certain areas over others, and just peoples reporting behaviors across neighborhoods that the model doesn't incorporate.\n\n# Part 10: Summary Statistics and Tables\n\n## Exercise 10.1: Model Summary Table\n\n```{r model-summary-table}\n# Create nice summary table\nmodel_summary <- broom::tidy(final_model, exponentiate = TRUE) %>%\n  mutate(\n    across(where(is.numeric), ~round(., 3))\n  )\n\nmodel_summary %>%\n  kable(\n    caption = \"Final Negative Binomial Model Coefficients (Exponentiated)\",\n    col.names = c(\"Variable\", \"Rate Ratio\", \"Std. Error\", \"Z\", \"P-Value\")\n  ) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  footnote(\n    general = \"Rate ratios > 1 indicate positive association with tree debris counts.\"\n  )\n```\n\n## Exercise 10.2: Key Findings Summary\n\n**Technical Performance:**\n\n-   Cross-validation MAE: 54.5\n-   Model vs. KDE: KDE\n-   Most predictive variable: potholes_sf.nn\n\n**Spatial Patterns:**\n\n-   Tree debris reports are clustered.\n-   Hot spots are located in South and Southwest neighborhoods and a little bit in the Westsides and Northsides of Chicago.\n-   Model errors show patterns of clustering of underprediciton and overprediction with district boundaries.\n\n**Model Limitations:**\n\n-   Overdispersion: Yes, by a lot. We had to use the NB model.\n-   Spatial autocorrelation in residuals: Yes, the error maps show clustered residuals.\n-   Cells with zero counts: 12.9%\n\n# Conclusion and Next Steps\n\nThis assignment has made a spatial prediction workflow for Chicago tree debris using 311 data and pothole as a predictor. While the Negative Binomial model identified strong relationships between disorder and tree debris, the spatial cross-validation and baseline comparison exercises demontrated that the KDE actually explains most of the variation anyway. Tree debris is strongly spatially autocorrelated, spatially clustered, and shaped by neighborhood(local)-level contextual factors that wern't in the model (like land use, storm exposure and intensities, and canopy cover). Future work should focus on incorporating tree canopy, storm data, other land use data.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"embed-resources":true,"output-file":"assignment4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.24","theme":"cosmo","title":"Predictive Policing - Technical Implementation","subtitle":"MUSA 5080 - Fall 2025","author":"Ryan Drake","date":"11/17/2025","editor":"visual","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}